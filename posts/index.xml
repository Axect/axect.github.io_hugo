<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Axect&#39;s Blog</title>
        <link>https://axect.github.io/posts/</link>
        <description>Recent content in Posts on Axect&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>kr</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Sat, 03 Oct 2020 03:36:49 +0900</lastBuildDate>
        <atom:link href="https://axect.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>🖊️ Differentiation with Rust 02: Symbolic Differentiation</title>
            <link>https://axect.github.io/posts/002_ad_2/</link>
            <pubDate>Sat, 03 Oct 2020 03:36:49 +0900</pubDate>
            
            <guid>https://axect.github.io/posts/002_ad_2/</guid>
            <description>🔖 Automatic Differentiation Series
 💻 Numerical Differentiation 🖊️ Symbolic Differentiation   📉 수치적 미분의 한계 저번 포스트에서 수치적 미분을 여러가지 방법으로 구현하는 것을 다뤄보았는데, 어떠셨나요? 아마, 코딩에 대한 조금의 지식만 있으면 오히려 고등학교때의 미분보다 훨씬 쉽게 느껴지셨을 겁니다. 저희가 사용한 것이라고는 그저 도함수의 정의에 따라 함수에 각 구간 값을 대입한 것이 전부였는데, 이를 코드로 나타내면 결국 다음의 코드에 지나지 않습니다.
# Python def differentiation(f, x, h=1e-06): return (f(x + h) - f(x)) / h 나머지는 이를 객체지향적으로 구현하거나, 함수형 프로그래밍으로 구현하거나 제너릭 프로그래밍을 도입하는 등의 구현방법의 차이일 뿐이었습니다.</description>
            <content type="html"><![CDATA[<blockquote>
<p><strong>🔖 Automatic Differentiation Series</strong></p>
<ol>
<li><a href="../02_ad_1">💻 Numerical Differentiation</a></li>
<li><a href="../02_ad_2">🖊️ Symbolic Differentiation</a></li>
</ol>
</blockquote>
<h2 id="-수치적-미분의-한계">📉 수치적 미분의 한계</h2>
<p>저번 포스트에서 수치적 미분을 여러가지 방법으로 구현하는 것을 다뤄보았는데, 어떠셨나요?
아마, 코딩에 대한 조금의 지식만 있으면 오히려 고등학교때의 미분보다 훨씬 쉽게 느껴지셨을 겁니다.
저희가 사용한 것이라고는 그저 도함수의 정의에 따라 함수에 각 구간 값을 대입한 것이 전부였는데, 이를 코드로 나타내면 결국 다음의 코드에 지나지 않습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">differentiation</span>(f, x, h<span style="color:#f92672">=</span><span style="color:#ae81ff">1e-06</span>):
  <span style="color:#66d9ef">return</span> (f(x <span style="color:#f92672">+</span> h) <span style="color:#f92672">-</span> f(x)) <span style="color:#f92672">/</span> h
</code></pre></div><p>나머지는 이를 객체지향적으로 구현하거나, 함수형 프로그래밍으로 구현하거나 제너릭 프로그래밍을 도입하는 등의 구현방법의 차이일 뿐이었습니다. 이렇게 수치적 미분 방법은 굉장히 간단한 구현과 엄청 빠른 계산속도를 가져서 누구나 쉽게 미분을 할 수 있게 해주었습니다만, 오차가 필연적으로 발생하게 되는 단점이 있었습니다. 따라서 오차에 크게 민감하지 않은 문제나, Step 수가 적어서 오차가 크게 쌓이지 않는 미분방정식을 푸는 경우엔 충분하지만, 오차에 민감하거나 Step 수가 많아서 오차가 쌓여 유의미한 차이를 보여주는 미분방정식의 경우엔 큰 문제를 야기할 수 있습니다. 대표적인 예시로 &ldquo;로렌즈의 나비&quot;가 있습니다.</p>
<h3 id="-로렌즈의-나비">🦋 로렌즈의 나비</h3>
<p><img src="/posts/images/euler.png" alt="Lorenz Butterfly"></p>
<p>에드워드 로렌즈는 걸출한 수학자로, 특히 카오스 이론의 선구자로 유명하신 분입니다. 그는 1963년에 대기 대류의 간단한 수학적 모형을 만들었는데, 이 모델은 다음의 3개의 상미분방정식으로 이루어져 있습니다.</p>
<p>$$
\begin{align}
\frac{dx}{dt} &amp;= \sigma(y-x) \\<br>
\frac{dy}{dt} &amp;= x (\rho - z) - y \\<br>
\frac{dz}{dt} &amp;= xy - \beta z
\end{align}
$$</p>
<p>분명 아주 간단한 미분방정식인데, 놀랍게도 아주 복잡한 형태의 해가 도출됩니다. 이때의 대표적인 해의 형태가 위에서 첨부한 그림입니다. 이 시스템은 굉장히 예민한데, 매개변수의 값을 조금 바꾸거나 혹은 Step size를 조금만 바꿔도 해의 형태는 예측할 수 없는 형태로, 그것도 굉장히 파격적으로 변형됩니다. 예를 들어 위의 그림은 <strong>오일러</strong>(Euler) 방법이라는 수치적 미분방정식 해법 중 하나로 풀었는데, 위와 모든 조건을 동일하게 놓고 방법만 <strong>룽게-쿠타</strong>(Runge-Kutta 4th order) 방법으로 바꾸면 다음의 그림이 나옵니다.</p>
<p><img src="/posts/images/rk4.png" alt="Lorenz Butterfly (RK4)"></p>
<p>오로지 방법만 바꾸었을 뿐인데 결과가 상당히 많이 다른 것을 볼 수 있습니다. 물론 이 경우에는 전체적인 형태는 바뀌지 않지만, 특정 매개변수 주변에서는 아예 형태 전체가 급격하게 변형되는 경우도 발생합니다. 이러한 경우에는 오차가 필연적으로 발생하는 수치적 미분 방법이 적합하지 않습니다. 그렇다면 이런 경우에는 어떻게 풀어야 할까요?</p>
<hr>
<h2 id="-기호적-미분-symbolic-differentiation">🇬🇷 기호적 미분 (Symbolic Differentiation)</h2>
<p>인간은 적절한 교육만 받는다면 미분을 아무런 오차없이 계산해낼 수 있습니다. (물론, 계산실수로 인한 오차는 종종 발생합니다.)
예를 들어 다음 함수의 도함수를 생각해봅시다.</p>
<p>$$
y = x^2
$$</p>
<p>이전 글에서 다루었다시피 수치적 미분 구현은 다음과 같습니다. 너무 똑같으면 심심하니 요즘 각광받는 수치 프로그래밍 언어인 Julia로 표현해보겠습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#75715e"># Julia</span>
<span style="color:#66d9ef">function</span> df(x, f, h<span style="color:#f92672">=</span><span style="color:#ae81ff">1e-06</span>)
  <span style="color:#66d9ef">return</span> (f(x<span style="color:#f92672">+</span>h) <span style="color:#f92672">-</span> f(x)) <span style="color:#f92672">/</span> h
<span style="color:#66d9ef">end</span>

<span style="color:#75715e"># Derivative</span>
dx2(x) <span style="color:#f92672">=</span> df(x, x <span style="color:#f92672">-&gt;</span> x<span style="color:#f92672">^</span><span style="color:#ae81ff">2</span>)

<span style="color:#75715e"># Print</span>
println(dx2(<span style="color:#ae81ff">1</span>)) <span style="color:#75715e"># 2.0000009999243673</span>
</code></pre></div><p>이번엔 고등학생이 푸는 방법을 살펴봅시다. (대한민국 고등학교 2학년 수학2 과정을 이수한 학생이라고 가정합니다.)</p>
<p>$$
\begin{align}
\frac{d}{dx}(x^2) &amp;= \lim_{h \rightarrow 0} \frac{(x+h)^2 - x^2}{h} \\<br>
&amp;= \lim_{h\rightarrow 0} \frac{2hx + h^2}{h} \\<br>
&amp;= 2x
\end{align}
$$</p>
<p>여기에 1을 대입하면 정확히 2가 나옵니다. 위에서 수치적 미분의 결과와 달리 오차는 포함되지 않았습니다.
미분을 배운 사람일 경우, 위 풀이는 전혀 어려운 풀이가 아닙니다. 규칙만 잘 지킨다면 다른 함수들을 미분할 때에도 큰 어려움은 없을 겁니다.</p>
<center id="img">
<figure>
    <img src="/posts/images/diff_table.gif"
         alt="물론 규칙이 조금 많긴 합니다 ㅎㅎ.."/> <figcaption style="text-align:center">
            <p>물론 규칙이 조금 많긴 합니다 ㅎㅎ..</p>
        </figcaption>
</figure>
</center>
<p>그렇다면 컴퓨터에게 규칙을 가르치면 어떨까요? 어떻게 가르치냐가 관건이겠지만 일단 가르칠 수 있다면 오차없는 완벽한 미분을 컴퓨터로 구현할 수 있을 것입니다.
다행히도 사람들은 이미 그것을 구현하였고 이를 <strong>CAS</strong>(Computer Algebra System)라 부릅니다.</p>
<p>대표적인 CAS로는 Mathematica, Matlab, Maple 등의 상업용 프로그램들과 Python으로 구현된 Sympy, Sagemath 등의 무료 프로그램 혹은 라이브러리가 있습니다.
CAS는 실제로 인간이 하는 것처럼 미분, 적분, 대수 뿐 아니라 심지어 미분기하 등의 고급 수학 문제까지도 풀어낼 수 있습니다.</p>
<center id="img">
<figure>
    <img src="/posts/images/sage_manifolds.png"
         alt="무려 이름도 SageManifolds 입니다."/> <figcaption style="text-align:center">
            <p>무려 이름도 SageManifolds 입니다.</p>
        </figcaption>
</figure>
</center>
<p>아래는 sagemath를 이용한 간단한 도함수 구현입니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">var(<span style="color:#e6db74">&#39;x&#39;</span>)        <span style="color:#75715e"># 변수를 선언합니다.</span>
f(x) <span style="color:#f92672">=</span> x<span style="color:#f92672">^</span><span style="color:#ae81ff">2</span>      <span style="color:#75715e"># 함수를 선언합니다.</span>
df <span style="color:#f92672">=</span> diff(f, x) <span style="color:#75715e"># 도함수를 계산합니다.</span>
<span style="color:#66d9ef">print</span>(df(<span style="color:#ae81ff">1</span>))    <span style="color:#75715e"># 2</span>
</code></pre></div><p>정확할 뿐만 아니라 간단하기까지 하니 더 이상 수치적 미분을 고집할 이유는 없어보입니다. 하지만 이렇게 엄청난 CAS에도 치명적인 단점이 존재합니다. 바로 속도입니다.
기호적 미분 자체는 계산 속도가 빠를 수 있지만 그것에 수치 값들을 대입할 때 현저하게 속도 저하가 일어납니다. 아래는 간단한 미분 계산에 크기가 큰 배열 값을 대입하여 성능을 측정한 결과입니다. Peroxide는 Rust의 수치계산 라이브러리 이름이며 후에 다룰 자동미분 알고리즘을 적용하여 계산을 수행하였고, numpy는 Python의 유명한 수치계산 라이브러리로 수치적 미분으로 계산하였습니다. 마지막으로 Sagemath는 기호적 미분으로 계산 후 수치 값을 대입하여 결과를 구했습니다.</p>
<center id="img">
<figure>
    <img src="/posts/images/plot.png"
         alt="Linear scale 그래프입니다."/> <figcaption style="text-align:center">
            <p>Linear scale 그래프입니다.</p>
        </figcaption>
</figure>
</center>
<center id="img">
<figure>
    <img src="/posts/images/logplot.png"
         alt="Log scale 그래프입니다."/> <figcaption style="text-align:center">
            <p>Log scale 그래프입니다.</p>
        </figcaption>
</figure>
</center>
<p>이 계산에 대한 정보를 더 알고 싶다면 다음 링크를 참고하시면 됩니다. <a href="https://github.com/Axect/Test/tree/master/diff_bench">Axect&rsquo;s Github link</a></p>
<p>물론 어떤 알고리즘을 사용했는지에 따라 실제 수치 계산에서의 결과는 조금 다를 수 있습니다. 다음은 Julia 언어 팀에서 실시한 Benchmark 결과입니다.</p>
<center id="img">
<figure>
    <img src="/posts/images/benchmarks.svg"
         alt="Log scale임을 참고하여 보시기 바랍니다. (출처: https://julialang.org/benchmarks/)"/> <figcaption style="text-align:center">
            <p>Log scale임을 참고하여 보시기 바랍니다. (출처: <a href="https://julialang.org/benchmarks/">https://julialang.org/benchmarks/</a>)</p>
        </figcaption>
</figure>
</center>
<p>그림을 보면 Matlab의 오픈소스 격인 Octave는 예외로 치더라도 Mathematica가 생각보단 느리지 않음을 알 수 있습니다. (그래도 C보다 거의 10~100배 느리긴 하지만요.)
Mathematica도 행렬 계산은 BLAS를 이용하고 갖가지 탁월한 수치 계산 알고리즘을 사용하기에 특정 계산들은 심지어 numpy를 이용한 Python보다 빠르기까지 합니다. 다만, Mathematica에서도 기호적 미분과 수치적인 연산을 서로 오갈때에는 역시나 큰 속도저하가 필연적으로 발생합니다.</p>
<p>그렇다면 규모가 큰 미분 계산에 대해서는 어떻게 접근해야할까요? 속도 저하를 고려하여 수치적 미분으로 구현하자니 규모가 커서 오차도 그만큼 많이 쌓일테고, 정확도를 고려하여 기호적 미분을 고려하자니 굉장히 오랜 시일이 걸릴 것은 뻔합니다. 심지어 메모리 문제로 게산 도중에 다운될 수도 있습니다. 다행히도 미분에 한해서는 거의 완벽한 해답이 존재합니다. 이에 대해서는 다음 포스트에서 다루도록 하겠습니다.</p>
<hr>
<h2 id="-부록">🔖 부록</h2>
<h3 id="a-로렌즈-나비-코드">A. 로렌즈 나비 코드</h3>
<p>위에서 첨부한 로렌즈 나비 그림들은 Rust의 수치 라이브러리인 <a href="https://github.com/Axect/Peroxide">Peroxide</a>를 이용하여 계산하였습니다. 소스코드는 다음과 같습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> peroxide;
<span style="color:#66d9ef">use</span> peroxide::fuga::<span style="color:#f92672">*</span>;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Box<span style="color:#f92672">&lt;</span>dyn Error<span style="color:#f92672">&gt;&gt;</span> {
    <span style="color:#75715e">// =========================================
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//  Declare ODE
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// =========================================
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> ex_test <span style="color:#f92672">=</span> ExplicitODE::new(butterfly);

    <span style="color:#66d9ef">let</span> init_state: <span style="color:#a6e22e">State</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> State::new(
        <span style="color:#ae81ff">0.0</span>,
        vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">10.0</span>, <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">1.0</span>],
        vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>],
    );

    ex_test
        .set_initial_condition(init_state)
        .set_method(ExMethod::Euler)
        .set_step_size(<span style="color:#ae81ff">0.01</span><span style="color:#66d9ef">f64</span>)
        .set_times(<span style="color:#ae81ff">10000</span>);

    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> ex_test2 <span style="color:#f92672">=</span> ex_test.clone();
    ex_test2.set_method(ExMethod::RK4);

    <span style="color:#75715e">// =========================================
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//  Save results
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// =========================================
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> results <span style="color:#f92672">=</span> ex_test.integrate();
    <span style="color:#66d9ef">let</span> results2 <span style="color:#f92672">=</span> ex_test2.integrate();

    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> df_euler <span style="color:#f92672">=</span> DataFrame::from_matrix(results);
    df_euler.set_header(vec<span style="color:#f92672">!</span>[<span style="color:#e6db74">&#34;t&#34;</span>, <span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#e6db74">&#34;y&#34;</span>, <span style="color:#e6db74">&#34;z&#34;</span>]);
    df_euler.print();

    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> df_rk4 <span style="color:#f92672">=</span> DataFrame::from_matrix(results2);
    df_rk4.set_header(vec<span style="color:#f92672">!</span>[<span style="color:#e6db74">&#34;t&#34;</span>, <span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#e6db74">&#34;y&#34;</span>, <span style="color:#e6db74">&#34;z&#34;</span>]);
    df_rk4.print();

    df_euler.write_nc(<span style="color:#e6db74">&#34;data/euler.nc&#34;</span>)<span style="color:#f92672">?</span>;
    df_rk4.write_nc(<span style="color:#e6db74">&#34;data/rk4.nc&#34;</span>)<span style="color:#f92672">?</span>;

    Ok(())
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">butterfly</span>(st: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> State<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span>, _: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">NoEnv</span>) {
    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>st.value;
    <span style="color:#66d9ef">let</span> dx <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> st.deriv;
    dx[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span><span style="color:#66d9ef">f64</span> <span style="color:#f92672">*</span> (x[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> x[<span style="color:#ae81ff">0</span>]);
    dx[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">28</span><span style="color:#66d9ef">f64</span> <span style="color:#f92672">*</span> x[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> x[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> x[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> x[<span style="color:#ae81ff">2</span>];
    dx[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">8</span><span style="color:#66d9ef">f64</span><span style="color:#f92672">/</span><span style="color:#ae81ff">3</span><span style="color:#66d9ef">f64</span> <span style="color:#f92672">*</span> x[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> x[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> x[<span style="color:#ae81ff">1</span>];
}
</code></pre></div><p>이후에 저장된 데이터를 불러와서 그림을 그리는 것은 Python으로 작성하였습니다. 코드는 다음과 같습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> netCDF4 <span style="color:#f92672">import</span> Dataset
<span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#f92672">as</span> plt

<span style="color:#75715e"># Import netCDF file</span>
ncfile1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;./data/euler.nc&#39;</span>
data1 <span style="color:#f92672">=</span> Dataset(ncfile1)
var1 <span style="color:#f92672">=</span> data1<span style="color:#f92672">.</span>variables
ncfile2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;./data/rk4.nc&#39;</span>
data2 <span style="color:#f92672">=</span> Dataset(ncfile2)
var2 <span style="color:#f92672">=</span> data2<span style="color:#f92672">.</span>variables

<span style="color:#75715e"># Use latex</span>
plt<span style="color:#f92672">.</span>rc(<span style="color:#e6db74">&#39;text&#39;</span>, usetex<span style="color:#f92672">=</span>True)
plt<span style="color:#f92672">.</span>rc(<span style="color:#e6db74">&#39;font&#39;</span>, family<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;serif&#39;</span>)

<span style="color:#75715e"># Prepare Plot</span>
plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">6</span>), dpi<span style="color:#f92672">=</span><span style="color:#ae81ff">300</span>)
plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;Lorenz Butterfly (Euler)&#34;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>)
plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;$x$&#39;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">14</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;$z$&#39;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">14</span>)

<span style="color:#75715e"># Prepare Data to Plot</span>
x1 <span style="color:#f92672">=</span> var1[<span style="color:#e6db74">&#39;x&#39;</span>][:]
z1 <span style="color:#f92672">=</span> var1[<span style="color:#e6db74">&#39;z&#39;</span>][:]  

<span style="color:#75715e"># Plot with Legends</span>
plt<span style="color:#f92672">.</span>plot(x1, z1, label<span style="color:#f92672">=</span><span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;Lorenz (Euler)&#39;</span>)

<span style="color:#75715e"># Other options</span>
plt<span style="color:#f92672">.</span>legend(fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>)
plt<span style="color:#f92672">.</span>grid()
plt<span style="color:#f92672">.</span>savefig(<span style="color:#e6db74">&#34;euler.png&#34;</span>, dpi<span style="color:#f92672">=</span><span style="color:#ae81ff">300</span>)

<span style="color:#75715e"># Prepare Plot</span>
plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">6</span>), dpi<span style="color:#f92672">=</span><span style="color:#ae81ff">300</span>)
plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;Lorenz Butterfly (RK4)&#34;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>)
plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;$x$&#39;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">14</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;$z$&#39;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">14</span>)

<span style="color:#75715e"># Prepare Data to Plot</span>
x2 <span style="color:#f92672">=</span> var2[<span style="color:#e6db74">&#39;x&#39;</span>][:]
z2 <span style="color:#f92672">=</span> var2[<span style="color:#e6db74">&#39;z&#39;</span>][:]  

<span style="color:#75715e"># Plot with Legends</span>
plt<span style="color:#f92672">.</span>plot(x2, z2, label<span style="color:#f92672">=</span><span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;Lorenz (RK4)&#39;</span>)

<span style="color:#75715e"># Other options</span>
plt<span style="color:#f92672">.</span>legend(fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>)
plt<span style="color:#f92672">.</span>grid()
plt<span style="color:#f92672">.</span>savefig(<span style="color:#e6db74">&#34;rk4.png&#34;</span>, dpi<span style="color:#f92672">=</span><span style="color:#ae81ff">300</span>)
</code></pre></div><p>이외에 자세한 사항은 <a href="https://github.com/Axect/Peroxide_Gallery">Peroxide Gallery</a>에 나와있으니 참고하시면 됩니다.</p>
]]></content>
        </item>
        
        <item>
            <title>🧙 Differentiation with Rust 01: Numerical Differentiation</title>
            <link>https://axect.github.io/posts/002_ad_1/</link>
            <pubDate>Sun, 24 May 2020 02:44:11 +0900</pubDate>
            
            <guid>https://axect.github.io/posts/002_ad_1/</guid>
            <description>미분은 희대의 천재였던 아이작 뉴턴이래로 없어서는 안 될 중요한 개념이 되었습니다. 문과나 이과 모두 구분없이 고등학교때 적어도 다항함수의 미분법은 배우며 이공계는 거의 모든 학과에서 미분방정식을 다룹니다. 물리학과의 경우는 좀 더 미분 의존도가 심한데, 당장 물리의 시작이라고 할 수 있는 고전역학부터 오일러-라그랑주 방정식(Euler-Lagrange equation)에 의존하며 물리학과의 핵심이라 할 수 있는 전자기학, 양자역학은 거의 모든 수식에 미분이 빠지지 않습니다.
당연하게도 수치 계산 분야에서도 미분은 항상 등장합니다. 다만, 인간이 미분을 이해하는 방식과 컴퓨터가 이해하는 방식은 차이가 있기에 미분을 받아들이는 방법 역시 조금 다릅니다.</description>
            <content type="html"><![CDATA[<p>미분은 희대의 천재였던 아이작 뉴턴이래로 없어서는 안 될 중요한 개념이 되었습니다.
문과나 이과 모두 구분없이 고등학교때 적어도 다항함수의 미분법은 배우며 이공계는 거의 모든 학과에서 미분방정식을 다룹니다. 물리학과의 경우는 좀 더 미분 의존도가 심한데, 당장 물리의 시작이라고 할 수 있는 고전역학부터 오일러-라그랑주 방정식(Euler-Lagrange equation)에 의존하며 물리학과의 핵심이라 할 수 있는 전자기학, 양자역학은 거의 모든 수식에 미분이 빠지지 않습니다.</p>
<p>당연하게도 수치 계산 분야에서도 미분은 항상 등장합니다. 다만, 인간이 미분을 이해하는 방식과 컴퓨터가 이해하는 방식은 차이가 있기에 미분을 받아들이는 방법 역시 조금 다릅니다. 일단 미적분학에서 간단하게 배우는 도함수의 정의는 다음과 같습니다.</p>
<p>$$
f'(x) = \lim_{h \rightarrow 0} \frac{f(x+h) - f(x)}{h}
$$</p>
<p>예를 들어 $f(x) = x^2$을 미분한다면 다음과 같이 간단하게 계산할 수 있습니다.</p>
<p>$$
\lim_{h \rightarrow 0} \frac{(x+h)^2 - x^2}{h} = \lim_{h \rightarrow 0}\frac{2hx + h^2}{h} = 2x
$$</p>
<p>하지만 컴퓨터가 이 문제를 접하게 된다면 상당히 난감한 상황에 놓입니다. <strong>극한</strong>이라는 개념이 컴퓨터의 구조와 대치되기 때문입니다.
$h$가 $0$으로 가는 극한이라는 것은 0에 한없이 가까이 접근한다는 의미로 $h$와 $0$의 차이가 그 어떤 숫자보다 작게 되어야 한다는 뜻인데, 컴퓨터는 구조 상 한없이 가까이 가는 것이 불가능합니다.
현재 대부분을 차지하고 있는 64bit 컴퓨터는 $2^{-53}$ 이하, 즉, 대략 $10^{-16}$이하의 차이는 $0$과 구분할 수 없습니다.
따라서 사람들은 크게 두 가지 방식으로 이를 해결하였습니다.</p>
<p> </p>
<hr>
<h2 id="-수치적-미분-numerical-differentiation">💻 수치적 미분 (Numerical Differentiation)</h2>
<p>컴퓨터는 극한을 본질적으로 다룰 수 없지만, 대부분의 계산에서는 $10^{-16}$ 정도면 아주 충분한 정밀도일 수 있습니다. 혹은 단위를 조정하면서 충분한 정밀도가 되도록 만드는 방법도 존재합니다.
따라서 극한을 다루는 대신 아주 작은 $h$를 이용하여 극한의 근삿값을 구하여 계산에 이용할 수 있는데, 이러한 방법을 <strong>수치적 미분</strong>이라 합니다. 일단 아주 간단하게 수치적 미분을 구현해보겠습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">diff</span>(f, x, h):
    <span style="color:#66d9ef">return</span> (f(x<span style="color:#f92672">+</span>h) <span style="color:#f92672">-</span> f(x)) <span style="color:#f92672">/</span> h
</code></pre></div><p>수치적 미분의 Python 구현은 놀라울 정도로 아주 간단합니다. 함수와 변수 그리고 정밀도를 넣어주면 바로 미분값이 나옵니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// Rust
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">diff</span><span style="color:#f92672">&lt;</span>F: Fn(<span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span>(f: <span style="color:#a6e22e">F</span>, x: <span style="color:#66d9ef">f64</span>, h: <span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span> {
    (f(x<span style="color:#f92672">+</span>h) <span style="color:#f92672">-</span> f(x)) <span style="color:#f92672">/</span> h
}
</code></pre></div><p>Rust 구현도 비교적 간단한 편이지만, 타입을 명시해야 되는 점이 Python과의 차이를 만듭니다. Rust에서 함수를 인수로 받을 때는 위와 같이 제너릭 타입(Generic Type)으로 받는 것이 좋습니다. 그래야 명시적 함수나 클로저(Closure) 구분 없이 사용할 수 있습니다.
이 코드들을 이용하여 $f(x) = x^2$의 $x=1$에서의 미분 계수를 구해봅시다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// Rust
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, diff(f, <span style="color:#ae81ff">1</span><span style="color:#66d9ef">f64</span>, <span style="color:#ae81ff">1e-6</span>));
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">diff</span><span style="color:#f92672">&lt;</span>F: Fn(<span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span>(f: <span style="color:#a6e22e">F</span>, x: <span style="color:#66d9ef">f64</span>, h: <span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span> {
    (f(x<span style="color:#f92672">+</span>h)<span style="color:#f92672">-</span>f(x)) <span style="color:#f92672">/</span> h
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">f</span>(x: <span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span> {
    x.powi(<span style="color:#ae81ff">2</span>)
}
</code></pre></div><p>코드에서 알 수 있듯이 정밀도는 $h=10^{-6}$을 대입하여 계산하였습니다. 결과는 $2.0000009999243673$으로 소숫점 6번째 자리까지는 이론 값인 $2$와 일치함을 보여줍니다. 이 수치적 미분코드는 간단하고 빠르게 미분 값을 구할 수 있다는 장점이 있지만, 도함수를 구하기 위해서는 반복적으로 함수를 대입해야 된다는 점에서 불편함을 야기합니다. 따라서 도함수를 구하기 위해서는 조금 더 코드를 늘려야 합니다. 먼저 구조체를 이용하는 객체지향적 방법을 사용하여 구현해보겠습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// Rust
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Derivative</span><span style="color:#f92672">&lt;</span>F: Fn(<span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">pub</span> f: <span style="color:#a6e22e">F</span>,
    <span style="color:#66d9ef">pub</span> h: <span style="color:#66d9ef">f64</span>,
}

<span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>F: Fn(<span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span> Derivative<span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">f</span>(<span style="color:#f92672">&amp;</span>self, x: <span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span> {
        (self.f)(x)
    }

    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">calc</span>(<span style="color:#f92672">&amp;</span>self, x: <span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span> {
        (self.f(x<span style="color:#f92672">+</span>self.h) <span style="color:#f92672">-</span> self.f(x)) <span style="color:#f92672">/</span> self.h
    }
}
</code></pre></div><p>이렇게 하면 함수와 정밀도는 초기 선언시에만 입력하면 되고, <code>calc</code> 메소드를 이용하여 여러 $x$ 값에서 계산이 가능해집니다. <code>f</code> 메소드는 보다 편하게 <code>self.f(x)</code>를 이용하기 위해 선언하였습니다. 만일 이러한 메소드가 없다면 <code>(self.f)(x)</code> 꼴로 입력해야만 합니다. 그럼 이제 이 코드를 이용하여 앞에서의 예시를 구현해봅시다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// Rust
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> df <span style="color:#f92672">=</span> Derivative {
        f,
        h: <span style="color:#ae81ff">1e-6</span>,
    };
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, df.calc(<span style="color:#ae81ff">1</span><span style="color:#66d9ef">f64</span>));
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">f</span>(x: <span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span> {
    x.powi(<span style="color:#ae81ff">2</span>)
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Derivative</span><span style="color:#f92672">&lt;</span>F: Fn(<span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">pub</span> f: <span style="color:#a6e22e">F</span>,
    <span style="color:#66d9ef">pub</span> h: <span style="color:#66d9ef">f64</span>,
}

<span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>F: Fn(<span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span> Derivative<span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">f</span>(<span style="color:#f92672">&amp;</span>self, x: <span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span> {
        (self.f)(x)
    }

    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">calc</span>(<span style="color:#f92672">&amp;</span>self, x: <span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span> {
        (self.f(x<span style="color:#f92672">+</span>self.h) <span style="color:#f92672">-</span> self.f(x)) <span style="color:#f92672">/</span> self.h
    }
}
</code></pre></div><p>당연하게도 답은 아까의 경우와 같게 나옵니다. 이번에는 진짜 &ldquo;도함수&quot;를 만드는 함수형 프로그래밍의 <em>고계 함수(Higher order function)</em> 개념을 이용하여 구현해보겠습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// Rust
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">derivative</span><span style="color:#f92672">&lt;</span>F: Fn(<span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span>(f: <span style="color:#a6e22e">F</span>, h: <span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#a6e22e">impl</span> Fn(<span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span> {
    <span style="color:#66d9ef">move</span> <span style="color:#f92672">|</span>x: <span style="color:#66d9ef">f64</span><span style="color:#f92672">|</span> (f(x<span style="color:#f92672">+</span>h) <span style="color:#f92672">-</span> f(x)) <span style="color:#f92672">/</span> h
}
</code></pre></div><p>일단 <code>F</code>로 <code>f64 -&gt; f64</code> 함수 역할을 하는 모든 타입을 받을 수 있다는 것은 앞에서와 같습니다. 다만 반환 타입 부분에 낯선 키워드들이 있습니다.
Rust의 Generic에는 크게 두 가지 방식이 존재합니다. 첫 번째는 앞서 봤던 <code>F</code>와 같이 Type placeholder를 사용하는 방식이고, 두 번째는 <code>impl Trait</code>처럼 <code>impl</code>키워드를 이용하는 방식이 있습니다. 두 방식 모두 큰 차이는 없지만, 여러 개의 타입이 같이 쓰일 때에 각 타입들이 같은 타입인지, 다른 타입인지 명확히 할 때에는 전자의 방식을 쓰고, 한 가지 타입만 사용하거나 타입 종류보다는 역할이 중요할 때에는 후자의 방식을 사용합니다. 예를 들어 위 코드를 Type placeholder를 이용하여 구현하면 다음과 같습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// Rust
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">derivative</span><span style="color:#f92672">&lt;</span>F, G<span style="color:#f92672">&gt;</span>(f: <span style="color:#a6e22e">F</span>, h: <span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#a6e22e">G</span> 
<span style="color:#66d9ef">where</span>
    F: Fn(<span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span>,
    G: Fn(<span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span>,
{
    <span style="color:#66d9ef">move</span> <span style="color:#f92672">|</span>x: <span style="color:#66d9ef">f64</span><span style="color:#f92672">|</span> (f(x<span style="color:#f92672">+</span>h) <span style="color:#f92672">-</span> f(x)) <span style="color:#f92672">/</span> h
}
</code></pre></div><p>아래의 구현이 가독성 면에서나 의미 면에서 좀 더 좋은 구현이지만, 이 함수를 사용할 때 제약이 심한 편입니다. <code>impl Trait</code> 꼴로 반환하면 Rust는 그 타입을 함수 본문에서 반환하는 값으로 자동 추론하여 사용하지만, Type placeholder로 반환하면 그 타입을 명확히 하기 전에는 컴파일 되지 않습니다.</p>
<p>또한 위와 같은 코드를 작성할 때, 클로저의 성질에 유의해야합니다. 클로저는 인수로 들어온 값이 아닌 주변 환경도 같이 캡쳐를 하는 성질이 있는데, 이때, 주변 변수들이 클로저 밖에서도 생존할 수 있다면 컴파일 오류가 발생합니다.
위 코드에서도 <code>f</code>와 <code>h</code>는 함수의 인수로 받았기에 함수의 선언이 끝나는 시점에 메모리가 해제됩니다. 하지만 반환되는 클로저는 <code>f</code>와 <code>h</code>의 값을 사용해야 합니다. 따라서 <code>move</code> 키워드를 이용하여 <code>f</code>와 <code>h</code>의 소유권을 클로저에 넘겨주어야 합니다.</p>
<p>이제 설명이 끝났으니 이 고계함수를 이용하여 도함수를 만들어 보겠습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// Rust
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> df <span style="color:#f92672">=</span> derivative(f, <span style="color:#ae81ff">1e-6</span>);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, df(<span style="color:#ae81ff">1</span><span style="color:#66d9ef">f64</span>));
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">f</span>(x: <span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span> {
    x.powi(<span style="color:#ae81ff">2</span>)
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">derivative</span><span style="color:#f92672">&lt;</span>F: Fn(<span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span>(f: <span style="color:#a6e22e">F</span>, h: <span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#a6e22e">impl</span> Fn(<span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#66d9ef">f64</span> {
    <span style="color:#66d9ef">move</span> <span style="color:#f92672">|</span>x: <span style="color:#66d9ef">f64</span><span style="color:#f92672">|</span> (f(x<span style="color:#f92672">+</span>h) <span style="color:#f92672">-</span> f(x)) <span style="color:#f92672">/</span> h
}
</code></pre></div><p>답은 위의 두 경우와 정확히 일치합니다.</p>
<p>그럼 이제 수치적 미분 방식의 장점과 단점을 요약해보겠습니다.</p>
<h3 id="수치적-미분의-장단점">수치적 미분의 장단점</h3>
<ul>
<li><strong>장점</strong>
<ul>
<li>구현하는 것이 굉장히 쉽다.</li>
<li>아주 빠르게 미분 계산을 수행할 수 있다.</li>
</ul>
</li>
<li><strong>단점</strong>
<ul>
<li>오차가 쌓이면서 실제 값과 많이 다른 값이 나올 수 있다.</li>
</ul>
</li>
</ul>
<p>계산 속도와 편의 상의 큰 장점을 가지고 있지만 오차가 계속 쌓일 수 있으므로 Step size는 작지만 구간은 긴 수치미분방정식 등은 수치적 미분을 적용하기에 한계가 있습니다.
다행히 이를 해결하기 위한 방법들은 존재합니다. 이에 대해서는 다음에 다뤄보도록 하겠습니다.</p>
]]></content>
        </item>
        
        <item>
            <title>🐪 Gaussian Conquest 01: Single variable</title>
            <link>https://axect.github.io/posts/001_gaussian/</link>
            <pubDate>Fri, 22 May 2020 17:00:31 +0900</pubDate>
            
            <guid>https://axect.github.io/posts/001_gaussian/</guid>
            <description>물리학이나 통계학 등을 하다보면 항상 마주치는 원수 같은 존재가 있습니다. 별로 어렵지는 않은데 마주칠 때마다 헷갈리는 그 존재는 바로 가우스 적분(Gaussian Integral)입니다.
$$\int_{-\infty}^\infty e^{-\alpha x^2} dx$$
이공계 대학생이라면 1학년 미적분학 시간에 극좌표계(Polar coordinate)를 이용한 이중적분을 다룰 때 나오는 가장 기본문제로 가우스 적분을 기억할겁니다. 그러나 항상 거의 모두가 그렇듯이 시간이 지나면 지날 수록 기억은 풍화되고 거의 망각의 단계에 이르렀을 때에 갑자기 튀어나오는 낯선 형태의 가우스 적분들은 대처하기가 난감합니다.
따라서 여기서는 가우스 적분과 가우시안 분포에 대한 아주 기본적인 성질들을 다시 상기시키고 이를 발판삼아 다변수 가우시안(Multivariate Gaussian)과 여러 활용들을 살펴보도록 하겠습니다.</description>
            <content type="html"><![CDATA[<p>물리학이나 통계학 등을 하다보면 항상 마주치는 원수 같은 존재가 있습니다. 별로 어렵지는 않은데 마주칠 때마다 헷갈리는 그 존재는 바로 <strong>가우스 적분</strong>(Gaussian Integral)입니다.</p>
<p>$$\int_{-\infty}^\infty e^{-\alpha x^2} dx$$</p>
<p>이공계 대학생이라면 1학년 미적분학 시간에 극좌표계(Polar coordinate)를 이용한 이중적분을 다룰 때 나오는 가장 기본문제로 가우스 적분을 기억할겁니다. 그러나 항상 거의 모두가 그렇듯이 시간이 지나면 지날 수록 기억은 풍화되고 거의 망각의 단계에 이르렀을 때에 갑자기 튀어나오는 낯선 형태의 가우스 적분들은 대처하기가 난감합니다.</p>
<p>따라서 여기서는 가우스 적분과 가우시안 분포에 대한 아주 기본적인 성질들을 다시 상기시키고 이를 발판삼아 다변수 가우시안(Multivariate Gaussian)과 여러 활용들을 살펴보도록 하겠습니다.</p>
<hr>
<h2 id="-기본적인-가우스-적분">🔢 기본적인 가우스 적분</h2>
<blockquote>
<p><strong>이해하기 위해 필요한 개념</strong></p>
<ul>
<li>고교 수준의 적분 (치환 적분, 지수함수의 적분)</li>
<li>극좌표계</li>
<li>이중적분</li>
</ul>
</blockquote>
<p>가우스 적분은 전형적인 <em>처음 하기는 힘들지만 한 번 보면 누구나 할 수 있는</em> 형태의 스킬입니다. 이것을 보고 극좌표계에서의 이중적분을 떠올리기는 힘들지만 그것을 사용한다는 것을 깨닫는 순간 문제는 아주 기초적인 미적분 문제로 격하됩니다. 그럼 먼저 가장 기본적인 가우스 적분을 봅시다.</p>
<p> </p>
<h3 id="일차원-가우스-적분">일차원 가우스 적분</h3>
<p>$$
\int_{-\infty}^\infty e^{-\alpha x^2} dx = \sqrt{\frac{\pi}{\alpha}}
$$</p>
<blockquote>
<p>이것을 바로 증명하기에는 어려움이 있으므로 제곱 꼴을 고려해야 합니다.
$$\left(\int_{-\infty}^\infty e^{-\alpha x^2}\right)^2 = \int_{-\infty}^\infty \int_{-\infty}^\infty e^{-\alpha(x^2 + y^2)} dx dy$$
이것을 $x^2 + y^2 = r^2,~dxdy = rdrd\theta$임을 이용하여 극좌표계 적분으로 변환합니다. 그렇다면 아주 간단한 치환 적분으로 적분을 계산할 수 있습니다.
$$\int_{0}^\infty \int_{0}^{2\pi} re^{-\alpha r^2} dr d\theta = \frac{\pi}{\alpha}$$
가우스 적분의 제곱이 위와 같은 결과가 되었고, 가우시안 함수($e^{-\alpha x^2}$)는 항상 양수이므로 위 식이 성립함을 알 수 있습니다.</p>
</blockquote>
<p>보통 물리학이나 통계학에서 자주 사용되는 가우스 적분은 다음과 같은 형태입니다.</p>
<p>$$
\int_{-\infty}^\infty e^{-\frac{a}{2}y^2} dy = (2\pi)^{\frac{1}{2}} a^{-\frac{1}{2}}
$$</p>
<p> </p>
<h3 id="일차원-가우스-적분-일반화">일차원 가우스 적분 일반화</h3>
<p>$$
(2\pi)^{-\frac{1}{2}}\int_{-\infty}^\infty e^{-\frac{1}{2}a x^2 + Jx} = a^{-\frac{1}{2}} e^{\frac{J^2}{2a}}
$$</p>
<blockquote>
<p>단순히 완전제곱식을 이용하여 정리하면 해결되는 적분입니다.
$$\int_{-\infty}^\infty e^{-\frac{a}{2}(y - \frac{J}{a})^2 + \frac{J^2}{2a}} = \int_{-\infty}^\infty e^{-\frac{a}{2}t^2} dt \cdot e^{\frac{J^2}{2a}}$$</p>
</blockquote>
<p>이런 형식의 적분은 평균이 0이 아닌 가우시안 분포나 양자 물리학의 경로 적분(Path Integral)에서 외부 힘(External force)이 작용할 때의 계산에서 많이 사용됩니다.</p>
<p> </p>
<h3 id="파인만-트릭을-이용한-가우스-적분">파인만 트릭을 이용한 가우스 적분</h3>
<p>$$
\int_{-\infty}^\infty x^2 e^{-a x^2}dx = \frac{1}{2}\pi^{\frac{1}{2}} a^{-\frac{3}{2}}
$$</p>
<blockquote>
<p>먼저 다음과 같이 가우스 적분을 $a$에 대한 함수로 정의합니다.
$$I(a) \equiv \int_{-\infty}^\infty e^{-ax^2} dx$$
이를 $a$에 대해 편미분 합니다.
$$\frac{\partial I(a)}{\partial a} = \int_{-\infty}^\infty -x^2 e^{-ax^2}dx$$
우리는 이미 $I(a)$의 값이 $\sqrt{\pi}{a}$임을 알고 있습니다. 따라서 위 식에서 좌변의 값은 다음과 같습니다.
$$\frac{\partial I(a)}{\partial a} = -\frac{1}{2}\pi^{\frac{1}{2}} a^{-\frac{3}{2}}$$
이제 위 식 2개가 같음을 이용하면 증명은 끝납니다.</p>
</blockquote>
<p>통상적으로 이런 적분은 부분적분(Partial integration)을 이용하는 것이 일반적이지만 파인만의 방법을 이용하면 이렇게 굉장히 쉽게 계산할 수 있습니다. 이런 트릭은 물리학에서는 일반적으로 사용되며 통계학에서도 아주 유용하게 사용할 수 있으므로 알아두면 큰 도움이 될 것입니다.</p>
<hr>
<h2 id="-단변수-가우시안-single-variate-gaussian">🐪 단변수 가우시안 (Single variate Gaussian)</h2>
<p><img src="/posts/images/single.png" alt="Single variate Gaussian"></p>
<h3 id="확률밀도함수-probability-density-function">확률밀도함수 (Probability Density Function)</h3>
<blockquote>
<p><strong>이해하기 위해 필요한 개념</strong></p>
<ul>
<li>고교 수준의 통계학</li>
</ul>
</blockquote>
<p>가우스 적분의 꽃은 역시 가우시안 분포라고 할 수 있습니다. 통계학에서 정규분포라고도 일컫는 이 확률 분포는 확률을 구하기 위해서 반드시 가우스 적분을 필요로 합니다. 단변수 가우시안 혹은 1차원 가우시안 분포의 확률밀도함수(Probability density function)은 다음과 같습니다.</p>
<p>$$
p(x) = \mathcal{N}(x | \mu, \sigma^2) = \frac{1}{\sqrt{2\pi \sigma^2}} \exp{\left(-\frac{1}{2\sigma^2}(x-\mu)^2 \right)}
$$</p>
<p>위 식에서 보다시피 단변수 가우시안 분포를 정의하기 위해서는 두 매개변수(Parameter) $\mu$와 $\sigma$가 필요합니다. 이미 이 매개변수들의 의미를 알고 있는 사람들이 많을 것 같지만 일단은 매개변수 이상의 의미를 두지 않고 성질을 살펴보도록 하겠습니다.</p>
<p>위에서 확률밀도함수라고 미리 언급했지만, 징검다리도 두드려보고 건너 듯이 저 이상한 함수가 진짜 확률밀도함수인지 확인을 해봅시다. 확률밀도함수를 위시한 확률분포함수는 반드시 2가지의 조건을 충족해야 합니다.</p>
<ol>
<li>
<p>정규화(Normalization)
$$\int_{-\infty}^{\infty} p(x) dx = 1$$</p>
</li>
<li>
<p>음이 아닌 정부호(Nonnegative definite)
$$p(x) \geq 0$$</p>
</li>
</ol>
<p>위에서 정의한 가우시안 분포의 확률밀도함수는 지수함수 형태이므로 항상 0보다 큰 것은 자명합니다. 따라서 정규화 조건만 확인하면 징검다리가 안전함을 확인할 수 있습니다. 이미 눈치채셨을 수도 있겠지만 이 확률분포함수의 정규화 조건을 확인하는 것은 가우스 적분으로 해결할 수 있습니다.</p>
<p>$$
\int_{-\infty}^\infty \frac{1}{\sqrt{2\pi\sigma^2}}\exp\left(-\frac{1}{2\sigma^2}(x - \mu)^2\right) dx = \frac{1}{\sqrt{2\pi\sigma^2}} \sqrt{2\pi \sigma^2} = 1
$$</p>
<p>모든 조건을 확인했으니 우리가 정의한 가우시안 분포의 확률밀도함수가 진짜라는 것을 납득할 수 있습니다. 이제 이 분포의 성질을 보기 위해 기댓값(평균)과 표준편차를 구해보도록 하겠습니다.</p>
<p> </p>
<h3 id="기댓값-expectation-value">기댓값 (Expectation value)</h3>
<p>확률밀도함수가 주어졌을 때, 기댓값의 정의는 다음과 같습니다.</p>
<p>$$
\mathbb{E}[X] = \int_{-\infty}^\infty x p(x) dx
$$</p>
<p>이를 이용하여 단변수 가우시안 분포의 기댓값을 구해봅시다. 식이 조금 복잡할 수 있으니 상수는 제외하고 적분을 먼저 계산하겠습니다.</p>
<p>$$
\begin{align*}
\int_{-\infty}^\infty xe^{-\frac{(x - \mu)^2}{2\sigma^2}} dx &amp;= \int_{-\infty}^\infty (t + \mu) e^{-\frac{t^2}{2\sigma^2}} dt \\<br>
&amp;= \mu \sqrt{2\pi \sigma^2}
\end{align*}
$$</p>
<p>계산을 조금 설명하면, 첫 번째 줄에서는 단순히 $t=(x-\mu)$로 치환하여 전개하였고 이후, $t e^{-\frac{t^2}{2\sigma^2}}$이 기함수(Odd function)임을 이용, 적분 값이 0이 되므로 두번째 항만 가우스 적분을 이용하여 계산하였습니다.
이제 여기에 아까 잠깐 미뤄놓았던 상수를 곱해주면 다음과 같은 결과를 얻게 됩니다.</p>
<p>$$
\mathbb{E}[X] = \mu
$$</p>
<p>놀랍게도 그저 매개변수 중 하나인 줄 알았던 $\mu$가 사실은 분포의 평균을 담당하는 중요한 변수였습니다!
이제 여세를 몰아 표준편차도 구해봅시다.</p>
<p> </p>
<h3 id="표준편차-standard-deviation">표준편차 (Standard deviation)</h3>
<p>표준편차는 <em>분산 (Variance)</em> 을 구하면 자동으로 도출되는 값입니다. 분산의 정의는 다음과 같습니다.</p>
<p>$$
Var[X] = \mathbb{E}\left[(X - \mu)^2 \right]
$$</p>
<p>그럼 바로 계산을 시작해봅시다.</p>
<p>$$
\begin{align*}
\int_{-\infty}^\infty (x - \mu)^2 e^{-\frac{(x- \mu^2)}{2\sigma^2}} dx &amp;= \int_{-\infty}^\infty t^2 e^{-\frac{t^2}{2\sigma^2}} dt \\<br>
&amp;= \frac{1}{2} \pi^{\frac{1}{2}} \left(\frac{1}{2\sigma^2}\right)^{-\frac{3}{2}} \\<br>
&amp;= \sigma^2 \sqrt{2\pi\sigma^2}
\end{align*}
$$</p>
<p>이번에는 앞서 다뤘던 파인만 트릭을 이용하여 계산했습니다. 기댓값을 구할 때와 마찬가지로 상수만 다시 붙여주면 다음과 같은 결과가 나옵니다.</p>
<p>$$
Var[X] = \sigma^2
$$</p>
<p>여기에 더 나아가, 표준편차는 분산의 양의 제곱근으로 정의되므로 $\sigma$가 바로 표준편차라는 것을 알 수 있습니다.</p>
<p> </p>
<hr>
<h2 id="마치며">마치며</h2>
<p>이번 글에서는 1차원 단일 변수에 대한 간단한 가우스 적분을 알아보고 이에 대한 활용으로 단변수 가우시안 분포의 기본적인 성질을 알아보았습니다.
다음에는 이를 다차원으로 확장하여 행렬 꼴로 표현되는 가우스 적분과 다변수 가우시안 분포에 대해 알아보겠습니다.</p>
<p> </p>
<hr>
<h2 id="참고문헌">참고문헌</h2>
<ul>
<li>Russell L. Herman, <em>An introduction to Mathematical physics via oscillations</em>, 2012</li>
<li>Massimiliano Bonamente, <em>Statistics and Analysis of Scientific Data</em>, Springer, 2017</li>
</ul>
]]></content>
        </item>
        
    </channel>
</rss>
